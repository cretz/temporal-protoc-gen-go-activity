package main

import (
	"flag"
	"fmt"
	"strconv"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

const version = "0.1.0"

const (
	contextPackage  = protogen.GoImportPath("context")
	workflowPackage = protogen.GoImportPath("go.temporal.io/sdk/workflow")
)

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Parse()
	if *showVersion {
		fmt.Printf("protoc-gen-go-activity %v\n", version)
		return
	}

	var flags flag.FlagSet
	// TODO(cretz): Flags?

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			if err := (&generator{Plugin: gen, File: f}).generate(); err != nil {
				return fmt.Errorf("file %v failed: %w", f.Desc.Name(), err)
			}
		}
		return nil
	})
}

type generator struct {
	*protogen.Plugin
	*protogen.File
	*protogen.GeneratedFile
}

func (g *generator) generate() error {
	// We only generate services
	if len(g.Services) == 0 {
		return nil
	}
	g.GeneratedFile = g.NewGeneratedFile(g.GeneratedFilenamePrefix+"_temporal.pb.go", g.GoImportPath)

	// Header
	g.P("// Code generated by protoc-gen-go-activity. DO NOT EDIT.")
	g.P()
	g.P("package ", g.GoPackageName)
	g.P()
	for _, service := range g.Services {
		if err := g.service(service); err != nil {
			return fmt.Errorf("service %v failed: %w", service.Desc.Name(), err)
		}
	}
	return nil
}

func (g *generator) service(service *protogen.Service) error {
	// Generate what workflows call. Each call is a method on an unexported empty
	// struct. An exported var of the unexported struct is instantiated for use.
	structName := strings.ToLower(service.GoName[:1]) + service.GoName[1:]
	g.Annotate(structName, service.Location)
	g.P("type ", structName, " struct{}")
	g.P()
	varComments := protogen.Comments(" " + service.GoName + " is for workflows to call for executing activities.")
	if service.Comments.Leading != "" {
		varComments += "\n\n" + service.Comments.Leading
	}
	g.P(varComments, "var ", service.GoName, " ", structName)
	g.P()
	for _, method := range service.Methods {
		if err := g.workflowMethod(structName, method); err != nil {
			return fmt.Errorf("method %v failed: %w", method.Desc.Name(), err)
		}
	}

	// Generate the interface for workers to implement
	ifaceName := service.GoName + "Impl"
	g.Annotate(structName, service.Location)
	ifaceComments := protogen.Comments(" " + ifaceName + " is for activity implementations on workers. " +
		"The struct that implements this can be passed to RegisterActivity.")
	if service.Comments.Leading != "" {
		ifaceComments += "\n\n" + service.Comments.Leading
	}
	g.P(ifaceComments, "type ", ifaceName, " interface {")
	for _, method := range service.Methods {
		if err := g.activityMethodSig(ifaceName, method); err != nil {
			return fmt.Errorf("method %v failed: %w", method.Desc.Name(), err)
		}
	}
	g.P("}")
	g.P()
	return nil
}

func (g *generator) workflowMethod(structName string, method *protogen.Method) error {
	// We don't support streaming calls
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		return fmt.Errorf("streaming not supported")
	}

	// Signature
	g.Annotate(structName+"."+method.GoName, method.Location)
	g.P(
		method.Comments.Leading,
		"func (", structName, ") ", method.GoName,
		"(ctx ", g.QualifiedGoIdent(workflowPackage.Ident("Context")),
		", in *", g.QualifiedGoIdent(method.Input.GoIdent),
		") (",
		"out *", g.QualifiedGoIdent(method.Output.GoIdent),
		", err error) {",
	)

	// Default the parameter if nil given
	g.P("if in == nil {")
	g.P("in = new(", g.QualifiedGoIdent(method.Input.GoIdent), ")")
	g.P("}")

	// Invoke ExecuteActivity and return
	g.P("err = ", g.QualifiedGoIdent(workflowPackage.Ident("ExecuteActivity")), "(ctx, ",
		strconv.Quote(method.GoName), ", in).Get(ctx, &out)")
	g.P("return")
	g.P("}")
	g.P()
	return nil
}

func (g *generator) activityMethodSig(ifaceName string, method *protogen.Method) error {
	// We don't support streaming calls
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		return fmt.Errorf("streaming not supported")
	}

	// Signature
	g.Annotate(ifaceName+"."+method.GoName, method.Location)
	g.P(
		method.Comments.Leading,
		method.GoName,
		"(", g.QualifiedGoIdent(contextPackage.Ident("Context")), ", *", g.QualifiedGoIdent(method.Input.GoIdent),
		") (", "*", g.QualifiedGoIdent(method.Output.GoIdent), ", error)",
	)
	g.P()
	return nil
}
